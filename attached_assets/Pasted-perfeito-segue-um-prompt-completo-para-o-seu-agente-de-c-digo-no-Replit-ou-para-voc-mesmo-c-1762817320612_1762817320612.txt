perfeito â€” segue um **prompt completo para o seu agente de cÃ³digo no Replit** (ou para vocÃª mesmo) corrigindo a inversÃ£o das odds, espelhando a Polymarket de forma invisÃ­vel ao usuÃ¡rio, atualizando a cada 60s e **congelando** quando houver variaÃ§Ã£o â‰¥5% em 1 minuto. Inclui: instruÃ§Ãµes, arquitetura, endpoints, **cÃ³digo TS/Node** (backend + adaptador Polymarket), funÃ§Ãµes utilitÃ¡rias, e ajustes no front. Copie e cole tudo abaixo no seu agente.

---

# ğŸ¯ OBJETIVO (leia antes de codar)

1. **Consertar odds invertidas** (SIM/YES e NÃƒO/NO) em todos os lugares.
2. **Espelhar** mercados da Polymarket em **mercados Palpites.AI** (o usuÃ¡rio *sÃ³* vÃª Palpites.AI).
3. **Atualizar odds** a cada **60s**.
4. Se a odd mudar **â‰¥5% em 1 min**, **congelar** a atualizaÃ§Ã£o visÃ­vel desse mercado atÃ©:

   * duas leituras consecutivas ficarem dentro do limiar (<5% do Ãºltimo valor estÃ¡vel), **ou**
   * decorrido um **timeout de 120s** (fail-safe).
5. Aplicar **spread interno de 2%** nas execuÃ§Ãµes (o cliente **nÃ£o** vÃª esse spread na UI).
6. Garantir **mapeamento correto** do â€œYes/Noâ€ vindo da Polymarket â†’ â€œSIM/NÃƒOâ€ local.
7. Tudo versionado e isolado em um **serviÃ§o de espelhamento** + **API** consumida pelo front.

---

# ğŸ§© VARIÃVEIS DE AMBIENTE (adicione em *Secrets* no Replit)

```
ENABLE_POLYMARKET=true
POLYMARKET_GAMMA_URL=https://gamma-api.polymarket.com
POLYMARKET_CLOB_URL=https://clob.polymarket.com
POLYMARKET_SLUGS=us-recession-in-2025,fed-rate-hike-in-2025,fed-emergency-rate-cut-in-2025,br-presidential-first-round-outright
SPREAD_BPS=200            # 2% = 200 bps
MIRROR_POLL_MS=60000      # 60s
MIRROR_SPIKE_THRESHOLD=0.05     # 5% (em probabilidade)
MIRROR_STABILIZE_NEED=2         # 2 leituras consecutivas estÃ¡veis
MIRROR_FAILSAFE_SEC=120
PORT=3000
```

> use os **slugs reais** que vocÃª definiu. O front **NÃƒO** deve chamar Polymarket diretamente â€” sÃ³ as rotas locais.

---

# ğŸ—ï¸ ARQUITETURA (resumo)

* **mirror-service/**: worker que busca Polymarket, normaliza (garante YES/NO correto), aplica lÃ³gica de **freeze** e publica em cache (em memÃ³ria ou Redis, se disponÃ­vel).
* **api/**: expÃµe somente rotas da **Palpites.AI**:

  * `GET /api/markets` â†’ lista de mercados (com odds exibÃ­veis, jÃ¡ estÃ¡veis/freeze-aware)
  * `GET /api/markets/:slug` â†’ detalhe
  * **(execuÃ§Ã£o)** `POST /api/orders/preview` e `POST /api/orders` â†’ aplicam **spread interno** 2% na precificaÃ§Ã£o efetiva (o front mostra sem spread).
* **frontend**: troca chamadas diretas por `/api/markets*`; remove qualquer rastro visual â€œPolymarketâ€.

---

# ğŸ“¦ ESTRUTURA DE ARQUIVOS (sugestÃ£o)

```
/server
  /src
    /mirror
      adapter.polymarket.ts
      mirror.state.ts
      mirror.worker.ts
    /pricing
      odds.ts
      spread.ts
    /api
      markets.routes.ts
      orders.routes.ts
      server.ts
    /types.ts
    /utils/logger.ts
  package.json
```

---

# ğŸ“ TIPOS BÃSICOS (server/src/types.ts)

```ts
export type Side = 'YES' | 'NO';

export interface MirrorMarket {
  slug: string;            // slug local (igual ao Polymarket para referÃªncia)
  title: string;
  category?: string;
  volumeUsd?: number;
  // Probabilidade verdadeira vindo da fonte (0..1) â€” usada internamente
  probYes_raw: number;
  probNo_raw: number;      // = 1 - probYes_raw
  // Probabilidade exibÃ­vel (apÃ³s lÃ³gica de freeze). O front usa estas:
  probYes_display: number;
  probNo_display: number;
  // Estado de estabilidade/congelamento
  frozen: boolean;
  freezeReason?: 'SPIKE' | 'MANUAL';
  lastStableYes: number;   // Ãºltimo valor estÃ¡vel exibido
  lastUpdate: number;      // epoch ms da Ãºltima leitura
}

export interface MirrorSnapshot {
  markets: Record<string, MirrorMarket>;
  updatedAt: number;
}
```

---

# ğŸ”¢ UTILITÃRIOS DE ODDS E SPREAD (server/src/pricing/odds.ts)

```ts
// conversÃµes seguras
export const clamp01 = (p: number) => Math.max(0, Math.min(1, p));

// prob (0..1) -> odds decimais (pagamento x)
export const probToDecimal = (p: number) => (p <= 0 ? Infinity : Number((1 / p).toFixed(2)));

// odds decimais -> prob (0..1)
export const decimalToProb = (o: number) => clamp01(1 / o);

// aplica 2% de spread internamente (em probabilidade efetiva de compra)
// regra simples: buy YES paga um "premium", buy NO idem (simetria)
export const applySpreadOnExecution = (probYes: number, bps: number, side: 'YES'|'NO') => {
  const spread = bps / 10000; // 200 bps -> 0.02
  if (side === 'YES') {
    // encarece YES: aumenta prob efetiva (pagar mais caro)
    const p = clamp01(probYes * (1 + spread));
    return { probYes_exec: p, probNo_exec: 1 - p };
  } else {
    // encarece NO: diminui probYes (equivale a pagar mais caro no NO)
    const p = clamp01(probYes * (1 - spread));
    return { probYes_exec: p, probNo_exec: 1 - p };
  }
};
```

---

# ğŸ’± ADAPTADOR POLYMARKET (server/src/mirror/adapter.polymarket.ts)

> **CorreÃ§Ã£o de inversÃ£o**: sempre ler o rÃ³tulo do outcome; mapear `'Yes'|'YES'` â†’ YES, e `'No'|'NO'` â†’ NO. Nunca assumir ordem no array.

```ts
import fetch from 'node-fetch';
import { clamp01 } from '../pricing/odds';

const GAMMA = process.env.POLYMARKET_GAMMA_URL!;
const CLOB  = process.env.POLYMARKET_CLOB_URL!;

export interface PolyMarketRaw {
  slug: string;
  question: string;
  outcomes: Array<{ name: string; price?: number; lastPrice?: number }>;
  volume?: number;
}

function extractProbYes(raw: PolyMarketRaw): number {
  // Tenta localizar outcome rotulado como "Yes" (case-insensitive)
  const yes = raw.outcomes.find(o => /^yes$/i.test(o.name));
  const no  = raw.outcomes.find(o => /^no$/i.test(o.name));

  // Polymarket normalmente expressa preÃ§o do YES em "cents" (0..1)
  // Algumas respostas vÃªm em price ou lastPrice; preferir price.
  const yesP = yes?.price ?? yes?.lastPrice;
  const noP  = no?.price ?? no?.lastPrice;

  if (typeof yesP === 'number') {
    return clamp01(yesP);
  }
  if (typeof noP === 'number') {
    // se sÃ³ houver preÃ§o do NO, usa 1 - no
    return clamp01(1 - noP);
  }
  // fallback: se nÃ£o veio preÃ§o, nÃ£o quebrar
  return 0.5;
}

export async function fetchPolyBySlug(slug: string): Promise<{ probYes: number; title: string; volumeUsd?: number }> {
  // 1) buscar metadata/odds no Gamma
  const metaRes = await fetch(`${GAMMA}/markets?slug=${encodeURIComponent(slug)}`);
  if (!metaRes.ok) throw new Error(`Gamma fetch failed: ${metaRes.status}`);
  const arr = (await metaRes.json()) as PolyMarketRaw[];
  const m = arr[0];
  if (!m) throw new Error(`Market not found for slug=${slug}`);

  const probYes = extractProbYes(m);
  return {
    probYes,
    title: m.question,
    volumeUsd: m.volume,
  };
}
```

> **Obs.**: se o endpoint exato diferir, mantenha a lÃ³gica: **achar explicitamente o outcome â€œYesâ€** por **nome**, nunca por posiÃ§Ã£o.

---

# â„ï¸ ESTADO & LÃ“GICA DE FREEZE (server/src/mirror/mirror.state.ts)

```ts
import { MirrorMarket, MirrorSnapshot } from '../types';

const SPIKE_TH = Number(process.env.MIRROR_SPIKE_THRESHOLD ?? 0.05);
const NEED_STABLE = Number(process.env.MIRROR_STABILIZE_NEED ?? 2);
const FAILSAFE_SEC = Number(process.env.MIRROR_FAILSAFE_SEC ?? 120);

const state: MirrorSnapshot = {
  markets: {},
  updatedAt: Date.now(),
};

function shouldFreeze(prevStableYes: number, newYes: number): boolean {
  const delta = Math.abs(newYes - prevStableYes);
  return delta >= SPIKE_TH;
}

export function getSnapshot(): MirrorSnapshot {
  return state;
}

export function upsertMarket(slug: string, payload: {
  title: string;
  probYes_raw: number;
  volumeUsd?: number;
}) {
  const now = Date.now();
  const prev = state.markets[slug];

  if (!prev) {
    state.markets[slug] = {
      slug,
      title: payload.title,
      volumeUsd: payload.volumeUsd,
      probYes_raw: payload.probYes_raw,
      probNo_raw: 1 - payload.probYes_raw,
      probYes_display: payload.probYes_raw,
      probNo_display: 1 - payload.probYes_raw,
      frozen: false,
      lastStableYes: payload.probYes_raw,
      lastUpdate: now,
    };
    state.updatedAt = now;
    return;
  }

  // Atualiza valores crus
  prev.probYes_raw = payload.probYes_raw;
  prev.probNo_raw = 1 - payload.probYes_raw;
  prev.volumeUsd = payload.volumeUsd;
  prev.lastUpdate = now;

  // LÃ³gica de freeze
  if (!prev.frozen) {
    if (shouldFreeze(prev.lastStableYes, payload.probYes_raw)) {
      prev.frozen = true;
      prev.freezeReason = 'SPIKE';
      // mantÃ©m display no Ãºltimo estÃ¡vel
      prev.probYes_display = prev.lastStableYes;
      prev.probNo_display = 1 - prev.lastStableYes;
      // anotar contador interno
      (prev as any).__stableCount = 0;
      (prev as any).__frozenAt = now;
    } else {
      // sem spike â†’ atualiza display e lastStable
      prev.probYes_display = payload.probYes_raw;
      prev.probNo_display = 1 - payload.probYes_raw;
      prev.lastStableYes = payload.probYes_raw;
    }
  } else {
    // congelado: verificar se estabilizou
    const within = !shouldFreeze(prev.lastStableYes, payload.probYes_raw);
    if (within) {
      (prev as any).__stableCount = ((prev as any).__stableCount ?? 0) + 1;
    } else {
      (prev as any).__stableCount = 0;
    }
    const elapsed = (now - ((prev as any).__frozenAt ?? now)) / 1000;

    if (((prev as any).__stableCount ?? 0) >= (Number(process.env.MIRROR_STABILIZE_NEED) || 2) || elapsed >= FAILSAFE_SEC) {
      // descongela e joga display para o valor cru atual
      prev.frozen = false;
      prev.freezeReason = undefined;
      prev.probYes_display = payload.probYes_raw;
      prev.probNo_display = 1 - payload.probYes_raw;
      prev.lastStableYes = payload.probYes_raw;
      delete (prev as any).__stableCount;
      delete (prev as any).__frozenAt;
    } else {
      // continua congelado, display permanece no lastStable
      prev.probYes_display = prev.lastStableYes;
      prev.probNo_display = 1 - prev.lastStableYes;
    }
  }

  state.updatedAt = now;
}
```

---

# ğŸ” WORKER DE ESPELHO (server/src/mirror/mirror.worker.ts)

```ts
import { fetchPolyBySlug } from './adapter.polymarket';
import { upsertMarket } from './mirror.state';

const POLY_SLUGS = (process.env.POLYMARKET_SLUGS ?? '')
  .split(',')
  .map(s => s.trim())
  .filter(Boolean);

export async function pollOnce() {
  for (const slug of POLY_SLUGS) {
    try {
      const { probYes, title, volumeUsd } = await fetchPolyBySlug(slug);
      upsertMarket(slug, { title, probYes_raw: probYes, volumeUsd });
    } catch (e) {
      console.error('[mirror] fetch error', slug, e);
    }
  }
}

export function startMirror() {
  const interval = Number(process.env.MIRROR_POLL_MS ?? 60000);
  pollOnce(); // imediatamente
  setInterval(pollOnce, interval);
}
```

---

# ğŸŒ ROTAS DE MERCADO (server/src/api/markets.routes.ts)

```ts
import { Router } from 'express';
import { getSnapshot } from '../mirror/mirror.state';
import { probToDecimal } from '../pricing/odds';

const r = Router();

r.get('/markets', (req, res) => {
  const snap = getSnapshot();
  const items = Object.values(snap.markets).map(m => ({
    slug: m.slug,
    title: m.title,
    volume: m.volumeUsd,
    frozen: m.frozen,
    yes: {
      prob: m.probYes_display,
      decimal: probToDecimal(m.probYes_display),
      percent: Math.round(m.probYes_display * 1000) / 10, // 1 casa
    },
    no: {
      prob: m.probNo_display,
      decimal: probToDecimal(m.probNo_display),
      percent: Math.round(m.probNo_display * 1000) / 10,
    },
    updatedAt: snap.updatedAt,
  }));
  res.json({ markets: items, updatedAt: snap.updatedAt });
});

r.get('/markets/:slug', (req, res) => {
  const slug = req.params.slug;
  const snap = getSnapshot();
  const m = snap.markets[slug];
  if (!m) return res.status(404).json({ error: 'Not found' });
  res.json({
    slug: m.slug,
    title: m.title,
    volume: m.volumeUsd,
    frozen: m.frozen,
    yes: { prob: m.probYes_display, decimal: probToDecimal(m.probYes_display) },
    no:  { prob: m.probNo_display,  decimal: probToDecimal(m.probNo_display)  },
    updatedAt: snap.updatedAt,
  });
});

export default r;
```

---

# ğŸ’¸ ROTAS DE ORDENS (apply spread invisÃ­vel) (server/src/api/orders.routes.ts)

```ts
import { Router } from 'express';
import { getSnapshot } from '../mirror/mirror.state';
import { applySpreadOnExecution, probToDecimal } from '../pricing/odds';

const r = Router();
const BPS = Number(process.env.SPREAD_BPS ?? 200);

r.post('/orders/preview', (req, res) => {
  const { slug, side, amountBRL } = req.body as { slug: string, side: 'YES'|'NO', amountBRL: number };
  const m = getSnapshot().markets[slug];
  if (!m) return res.status(404).json({ error: 'Market not found' });
  if (m.frozen) return res.status(409).json({ error: 'Market temporarily frozen' });

  const exec = applySpreadOnExecution(m.probYes_display, BPS, side);
  const priceYesDecimal = probToDecimal(exec.probYes_exec);
  const priceNoDecimal  = probToDecimal(exec.probNo_exec);

  // shares estimadas (simples): shares = amount * odd_decimal
  const estShares = side === 'YES' ? amountBRL / priceYesDecimal : amountBRL / priceNoDecimal;

  res.json({
    slug,
    side,
    amountBRL,
    probabilityApplied: side === 'YES' ? exec.probYes_exec : exec.probNo_exec,
    decimalOddsApplied: side === 'YES' ? priceYesDecimal : priceNoDecimal,
    estimatedShares: Number(estShares.toFixed(4)),
    spreadBps: BPS,
    note: 'Spread aplicado de forma interna; UI nÃ£o exibe.'
  });
});

// Aqui sÃ³ simula a execuÃ§Ã£o. Seu backend real vai gravar ordem/trade/posiÃ§Ã£o.
r.post('/orders', (req, res) => {
  const { slug, side, amountBRL } = req.body;
  // ... validar saldo BRL3, etc.
  return res.json({ ok: true, slug, side, amountBRL });
});

export default r;
```

---

# ğŸš€ SERVER (server/src/api/server.ts)

```ts
import express from 'express';
import marketsRoutes from './markets.routes';
import ordersRoutes from './orders.routes';
import { startMirror } from '../mirror/mirror.worker';

const app = express();
app.use(express.json());

app.use('/api', marketsRoutes);
app.use('/api', ordersRoutes);

const port = Number(process.env.PORT ?? 3000);
app.listen(port, () => {
  console.log(`API listening on :${port}`);
  if (process.env.ENABLE_POLYMARKET === 'true') startMirror();
});
```

**package.json (trecho):**

```json
{
  "type": "module",
  "dependencies": {
    "express": "^4.19.2",
    "node-fetch": "^3.3.2"
  },
  "scripts": {
    "dev": "node --watch ./dist/api/server.js",
    "build": "tsc"
  }
}
```

---

# ğŸ§ª CHECKLIST DE CORREÃ‡ÃƒO (odds invertidas)

* [x] **Nunca** inferir YES/NO por Ã­ndice do array.
* [x] Sempre localizar outcome por **nome** `/^yes$/i` e `/^no$/i`.
* [x] Se vier apenas preÃ§o de NO, usar `1 - noPrice` para `probYes`.
* [x] UI **mostra** `probYes_display`/`probNo_display` (nÃ£o as â€œrawâ€).
* [x] Ordem de apresentaÃ§Ã£o em cards e detalhe:

  * **SIM** â†’ `probYes_display`,
  * **NÃƒO** â†’ `probNo_display`.
* [x] ConversÃ£o a **decimal odds** sÃ³ para exibiÃ§Ã£o (ex.: 1.04 vs 23.53).
* [x] Spread **apenas** em `/orders/preview` e `/orders` (invisÃ­vel na UI).

---

# ğŸ¨ AJUSTES NO FRONT (resumo)

1. Substituir chamadas diretas (ou mocks) por:

   * `GET /api/markets` para cards da Home e â€œMercados Polymarket (Beta)â€
   * `GET /api/markets/:slug` para a pÃ¡gina de detalhe
2. Em todos os componentes de exibiÃ§Ã£o:

   * **SIM**: usar `resp.yes.decimal`/`resp.yes.percent`
   * **NÃƒO**: usar `resp.no.decimal`/`resp.no.percent`
3. Ao clicar â€œComprar SIM/NÃƒOâ€:

   * chamar `POST /api/orders/preview` para mostrar estimativa (com spread **jÃ¡ aplicado** internamente)
   * confirmar com `POST /api/orders`
4. Exibir â€œMercado temporariamente congeladoâ€ quando `frozen=true`.

---

# ğŸ”’ REGRAS DE NEGÃ“CIO VISUAIS (o usuÃ¡rio nÃ£o vÃª Polymarket)

* Cards/tÃ­tulos/descriÃ§Ãµes: **nÃ£o** mencionar â€œPolymarketâ€.
* â€œOdds espelhadasâ€ pode ficar numa linha cinza discreta no admin, **nÃ£o** no pÃºblico.
* Em `Portfolio`, as posiÃ§Ãµes continuam Palpites.AI; liquidaÃ§Ã£o seguirÃ¡ sua regra local.

---

# ğŸ§­ CRITÃ‰RIOS DE ACEITAÃ‡ÃƒO

* âœ… Probabilidades e odds **corretas e nÃ£o invertidas** em todos os cards e pÃ¡ginas.
* âœ… AtualizaÃ§Ã£o automÃ¡tica a cada **60s**.
* âœ… Ao detectar variaÃ§Ã£o **â‰¥5%** vs **lastStable** em 1 tick, o **display congela** (Ã­cone de snowflake opcional) mantendo a Ãºltima odd estÃ¡vel; **descongela** apÃ³s **2 leituras** consecutivas dentro do limiar **ou** **120s**.
* âœ… **Spread 2%** aplicado **somente** na execuÃ§Ã£o/preview; UI nÃ£o mostra.
* âœ… NÃ£o hÃ¡ qualquer texto/branding Polymarket no front pÃºblico.
* âœ… Rotas `/api/markets*` respondem com `yes/no` consistentes e `decimal` coerente.

---

# ğŸ§¹ DICAS FINAIS

* Se algum mercado da fonte mudar de binÃ¡rio para multi-outcome, **ignore** (logar aviso).
* Trate `NaN`/undefined com fallback `0.5` para nÃ£o quebrar o front.
* Se quiser **persistÃªncia** alÃ©m da memÃ³ria, plugar Redis (chave `mirror:snapshot`).
* Para grÃ¡ficos histÃ³ricos, guarde sÃ©ries a cada `pollOnce` (opcional).

---

Pronto. Com isso vocÃª:

* corrige a **inversÃ£o** de SIM/NÃƒO,
* espelha odds com **atualizaÃ§Ã£o de 60s**,
* **congela** quando houver spikes,
* aplica spread **invisÃ­vel** na execuÃ§Ã£o,
* e mantÃ©m o usuÃ¡rio olhando **apenas** mercados Palpites.AI.
