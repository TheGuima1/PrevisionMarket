Segue direto o prompt robotizado pra você colar no Replit AI (ou outro agente). Ele já assume TODO o contexto do repositório `PrevisionMarket` e foca em:

1. **Corrigir o erro de depósito** (“Erro ao solicitar depósito”).
2. **Revisar e corrigir outros erros críticos do fluxo de depósitos/saques, admin e blockchain.**

---

### PROMPT ROBÓTICO PARA O REPLIT

Você é um agente de desenvolvimento rodando no Replit.
Seu objetivo é **inspecionar e corrigir o projeto `PrevisionMarket`** (prediction market com depósitos via PIX e mint/burn de BRL3 na Polygon) hospedado em:

> `https://github.com/TheGuima1/PrevisionMarket`

O foco principal é **consertar o erro de depósito** que aparece na tela de Carteira / Depósito:

> *"Erro ao solicitar depósito — Falha ao solicitar depósito. Tente novamente."*

Além disso, você deve **identificar e corrigir qualquer outro erro crítico** que impeça o fluxo completo de:

* depósito → aprovação admin → mint on-chain,
* saque → aprovação admin → burn on-chain.

---

## 0. Regras gerais

1. Trabalhe **diretamente no código do repositório clonado no Replit**, não crie um projeto novo.
2. **Não mude a arquitetura** (frontend em `client/`, backend em `server/`, schema compartilhado em `shared/`).
3. **Não remova lógica de negócio importante**; apenas corrija bugs, alinhando frontend ↔ backend ↔ banco ↔ blockchain.
4. Mantenha todas as variáveis de ambiente já usadas (não renomeie chaves `.env` existentes).
5. Sempre que fizer mudança significativa em rota ou componente crítico, adicione logs claros (`console.log`) para facilitar debug.

---

## 1. Contexto do projeto (use isso como verdade)

Do `README.md`:

* Frontend: **Vite + React** em `client/`
* Backend: **Express** (TypeScript) em `server/`
* Banco: **Postgres** via Drizzle (`shared/`)
* Comandos:

  * `npm install`
  * `npm run dev` → dev (client + server)
  * `npm run build` → build
  * `npm start` → produção
  * `npm run db:push` → sincronizar schema com o banco
* Variáveis importantes:

  * `DATABASE_URL` (Postgres – hoje está apontando para Supabase)
  * `SESSION_SECRET`
  * `PORT` (default 5000)
  * `VITE_POLYGON_RPC_URL` (opcional; se vazio usa `https://polygon-rpc.com`)
* Blockchain:

  * Network: Polygon Mainnet (`chainId 0x89`)
  * **Admin wallet**: `0xCD83c3f36396bcb3569240a3Cb34f037ba310926`
  * **BRL3 token**: `0x2F6370EC3b1ebB60cF359fb264E5e576ceEb6dcE`
  * Decimals: 18
  * Config + helpers: `client/src/blockchain/config.ts`
  * ABI: `client/src/blockchain/brl3Abi.ts`
  * MetaMask: `client/src/contexts/MetaMaskContext.tsx`, `client/src/lib/metamask-workflows.ts`
* Fluxo desejado de DEPÓSITO:

  1. Usuário, na aba **Carteira / Depositar**, informa valor em R$, wallet (vinda do MetaMask) e envia PDF.
  2. Backend cria um registro de depósito com status `pending`.
  3. Admin entra no painel `/admin` (aba Depósitos), conecta a MetaMask com a **carteira do admin**, confere o PDF e clica **“Approve & Mint”**.
  4. MetaMask executa o mint on-chain para a *wallet do usuário*.
  5. Após confirmação, o frontend envia `txHash` + `amountRaw` para `/api/deposits/:id/confirm-mint`.
  6. Backend atualiza status para `approved`, atualiza saldo off-chain e guarda `txHash`.

---

## 2. Preparação do ambiente

1. Garanta que o repositório `PrevisionMarket` já está clonado no Replit.
2. No terminal:

   * Rode `npm install`.
3. Abra o arquivo `.env` na raiz do projeto e confira:

   * `DATABASE_URL` está apontando para o **Postgres correto no Supabase**.

     * Se necessário, ajuste o connection string para incluir SSL se o driver exigir (ex.: `?sslmode=require`).
   * `SESSION_SECRET` tem um valor não vazio.
   * `VITE_POLYGON_RPC_URL` pode ficar vazio (usa RPC público) ou pode ser preenchido com um RPC público da Polygon.
4. Rode as migrações/sync de schema:

   * `npm run db:push`
   * Se aparecer qualquer erro aqui, **corrija antes de seguir** (por exemplo: problemas de permissão ou de conexão com o banco).
5. Inicie o ambiente de desenvolvimento:

   * `npm run dev`
   * Confirme no log do servidor que **a conexão com o banco foi estabelecida** sem erro.

---

## 3. Reproduzir o erro de DEPÓSITO

1. Com o dev server rodando, abra a aplicação local no navegador do Replit (ou na URL configurada).
2. Vá até a tela de **Carteira** (Portfolio → Carteira), aba **Depositar**.
3. Preencha:

   * Valor em R$: qualquer valor de teste (ex.: 100).
   * Upload de um PDF (pode ser qualquer PDF pequeno).
4. Clique em **“Solicitar Depósito”**.
5. No navegador, abra as **DevTools → Network** e observe a requisição que é disparada ao clicar no botão.

   * A requisição esperada é um `POST` para algo como `/api/deposits` (via fetch/axios do frontend).
6. Observe:

   * **URL exata** da rota chamada.
   * **Status code** (400, 404, 500, etc.).
   * Corpo da resposta (JSON ou HTML).
7. Em paralelo, observe o **console do servidor** no Replit e capture o erro que aparece no momento da requisição de depósito (stack trace, mensagem do Drizzle/Postgres, erro de multer, etc.).

---

## 4. Encontrar e corrigir a rota de DEPÓSITO no backend

1. Localize, dentro de `server/`, o arquivo da rota de depósitos. Procure por nomes como:

   * `depositRoutes.ts`
   * `deposits.ts`
   * `routes/deposits.ts`
   * ou por `app.post("/api/deposits"` ou algo semelhante.
2. Quando encontrar a rota principal de **criação de depósito** (POST),
   certifique-se de que ela:

   * Está registrada no `server/index.ts` ou `server/app.ts` (ou arquivo principal do Express).
   * Exporta corretamente o router e é montada em um prefixo como `/api`.
3. Dentro da rota de criação de depósito:

   * Liste exatamente os campos que ela espera no `req.body`:

     * Prováveis campos: `amount`, `walletAddress`, `pixCnpj`, `proofFilePath`, etc.
   * Verifique se está usando algum middleware de upload de arquivo (ex.: `multer`), e qual é o nome do campo do arquivo (`proof` ou `file`).

### 4.1. Alinhar frontend ↔ backend (body + upload)

1. Agora, vá para o frontend, dentro de `client/`, e encontre o componente da tela de carteira/depósito. Procure por:

   * `src/pages/Portfolio/Wallet.tsx`
   * `src/pages/portfolio/WalletPage.tsx`
   * `src/features/wallet/DepositForm.tsx`
   * ou qualquer arquivo que contenha o texto `"Solicitar Depósito"`.
2. Encontre a função que dispara a requisição de depósito (por exemplo, `handleSubmitDeposit`).
3. Verifique:

   * Qual URL está sendo usada (`/api/deposits`, `/api/deposit`, etc).
   * Quais campos estão sendo enviados no `FormData` ou JSON.
   * Qual é o nome do campo de upload (ex.: `proof`).
4. **Garanta que os nomes dos campos no frontend sejam exatamente os mesmos que o backend espera**, tanto:

   * Nos campos de texto (`amount`, `walletAddress`, etc.),
   * Quanto no campo de arquivo (por exemplo, se o backend usa `upload.single("proof")`, o `FormData` precisa usar `formData.append("proof", file)`).
5. Se houver qualquer divergência de nomes:

   * **Ajuste o frontend para bater com o backend** (preferência).
   * Ou, se fizer mais sentido, ajuste o backend, mas mantenha consistência com o resto do projeto.

---

## 5. Verificar problemas com o banco de dados

Na rota de depósito:

1. Procure chamadas ao Drizzle/DB, algo como:

   * `db.insert(deposits).values(...)`
   * ou `db.query.deposits.insert(...)`.
2. Verifique:

   * Se a tabela/objeto `deposits` existe em `shared/` (ex.: `shared/schema.ts`).
   * Se todos os campos obrigatórios da tabela estão sendo fornecidos.
3. Caso haja erro do tipo “relation does not exist” ou “column does not exist”:

   * Ajuste o schema em `shared/` para refletir a versão atual do banco **ou**
   * Rode `npm run db:push` novamente depois de ajustar o schema, para criar/alterar a tabela necessária.
4. Certifique-se de que, ao criar o registro do depósito, os seguintes pontos são válidos:

   * Há um campo de status (por exemplo, `status: "pending"`).
   * O valor é salvo em uma forma consistente:

     * Se o frontend envia `amount` em R$ (ex.: 100), o backend pode salvar:

       * `amountFiat: 100` (decimal), e/ou
       * `amountRaw: BigInt(100) * 10n**18n` (para on-chain).
5. Adicione logs **temporários**:

   * Antes de inserir: `console.log("[DEPOSIT] Incoming body:", req.body);`
   * No catch: `console.error("[DEPOSIT] Error creating deposit:", error);`

---

## 6. Verificar problemas de upload de arquivo

1. No backend, encontre a configuração de upload (provavelmente usando `multer`).

   * Veja em qual pasta está salvando o arquivo (deve ser algo como `uploads/deposit-proofs/`).
2. Confirme que a pasta `uploads/deposit-proofs` **existe fisicamente** no projeto (no Replit) e tem permissão de escrita.

   * Se não existir, crie a pasta.
3. Garanta que:

   * O middleware de upload está sendo aplicado na rota correta do Express (ex.: `router.post("/api/deposits", upload.single("proof"), handler)`).
   * O frontend envia um arquivo real na chave correta.
4. Trate o caso de nenhum arquivo enviado:

   * Se o arquivo for obrigatório, retorne `400` com uma mensagem clara (`"Deposit proof PDF is required"`).
   * Ajuste o frontend para exibir essa mensagem, se for esse o erro.

---

## 7. Padronizar resposta da rota de DEPÓSITO

Após corrigir as etapas acima, modifique a rota de criação de depósito para que:

1. No sucesso, retorne algo como:

   ```ts
   res.status(201).json({
     success: true,
     depositId: createdDeposit.id,
   });
   ```
2. Em caso de erro de validação (dados faltando, formato inválido):

   ```ts
   res.status(400).json({
     success: false,
     error: "VALIDATION_ERROR",
     message: "Mensagem clara do problema",
   });
   ```
3. Em caso de erro interno (DB, IO, etc.):

   ```ts
   res.status(500).json({
     success: false,
     error: "INTERNAL_ERROR",
     message: "Falha ao criar depósito. Tente novamente.",
   });
   ```

No frontend:

1. No `catch` da requisição de depósito:

   * Leia `error.response?.data?.message` (quando existir) e mostre na toast.
2. Ainda que a mensagem venha vazia, exiba uma fallback:

   * `"Erro ao solicitar depósito. Tente novamente em alguns instantes."`

---

## 8. Testes do fluxo de DEPÓSITO após correções

1. Recarregue o frontend.
2. Faça um novo teste de depósito:

   * Preencha valor e envie PDF.
3. Confirme:

   * O toast de erro **não aparece mais**.
   * Aparece um toast de sucesso (ou alguma confirmação visual).
   * O registro de depósito aparece em:

     * Tela de **Histórico / Depósitos** do usuário.
     * Painel do **admin** (aba Depósitos) com status `pending`.

Se algo ainda falhar:

* Volte ao Network/console e logs do servidor.
* Corrija qualquer novo erro que apareça, seguindo a mesma lógica acima.

---

## 9. Verificação de OUTROS ERROS CRÍTICOS (admin + saque + blockchain)

Depois de o depósito estar funcionando, faça uma varredura rápida nos outros pontos críticos:

### 9.1. Rotas de SAQUE

1. Localize a rota de criação de saque (`POST /api/withdrawals` ou similar).
2. Repita o mesmo processo:

   * Alinhar body do frontend com o backend.
   * Verificar inserção no banco.
   * Padronizar resposta JSON.
3. Teste o fluxo:

   * Usuário solicita saque na aba “Sacar via PIX”.
   * Verifique se o registro de saque é criado com status `pending`.
   * Verifique se aparece no painel do admin.

### 9.2. Rotas de CONFIRMAÇÃO (mint/burn)

1. Localize:

   * `POST /api/deposits/:id/confirm-mint`
   * `POST /api/withdrawals/:id/confirm-burn`
2. Garanta que:

   * Ambos recebem `txHash` e `amountRaw` do frontend.
   * Atualizam o status do registro (`approved` ou `completed`) e o saldo off-chain corretamente.
   * Validam que o `amountRaw` é coerente com a quantidade em R$ (1 BRL ↔ 1 BRL3, com 18 decimais on-chain).
3. Teste pelo painel admin:

   * Aprove um depósito e simule o envio correto do `txHash`.
   * Confira que o status muda e o saldo do usuário é atualizado.

### 9.3. Configuração da blockchain e MetaMask

1. Abra `client/src/blockchain/config.ts` (ou arquivo equivalente listado no README).
2. Confirme:

   * Endereço do contrato BRL3: `0x2F6370EC3b1ebB60cF359fb264E5e576ceEb6dcE`.
   * Decimals: 18.
   * ChainId: `0x89`.
3. Em `client/src/contexts/MetaMaskContext.tsx` e `client/src/lib/metamask-workflows.ts`:

   * Verifique se o fluxo para conectar MetaMask e selecionar a rede Polygon está correto.
   * Confirme que o admin precisa estar logado com a **carteira do admin** indicada no README para aprovar depósitos/saques.

---

## 10. Limpeza e documentação final

1. Remova logs de debug muito verbosos que não sejam mais necessários, mantendo apenas logs úteis em erros críticos.
2. Não remova arquivos importantes de schema, rotas ou componentes usados.
3. Se encontrar código claramente morto (rotas antigas nunca usadas, componentes não referenciados), comente brevemente essa limpeza em um arquivo de notas ou em comentários de código.

Por fim:

* Garanta que:

  * `npm run dev` roda sem erros.
  * É possível:

    * **Criar depósito** sem erro.
    * Ver depósito no painel admin.
    * Criar pedido de saque.
* Se qualquer rota crítica ainda retornar erro, corrija até o fluxo básico estar 100% funcional.

---

Fim do prompt.
