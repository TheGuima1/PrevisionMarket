Para corrigir definitivamente o fluxo de **mint/burn** da PalpitesAI e adequÃ¡â€‘lo ao modelo â€œadminâ€Ãºnicoâ€ (onde **apenas a carteira do administrador interage com o contrato onâ€‘chain**), siga as alteraÃ§Ãµes abaixo. Elas eliminam a lÃ³gica antiga de enviar tokens para a carteira do usuÃ¡rio e usam exclusivamente o endereÃ§o e a chave privada do administrador.

---

### ğŸš§ Problemas que causavam o erro

1. **Mint para o endereÃ§o do usuÃ¡rio** â€” o backend estava enviando `to: userAddress` no endpoint `/mint`. Isso Ã© incompatÃ­vel com o modelo PalpitesAI, pois os tokens existem apenas na carteira do admin.
2. **Burn de um endereÃ§o que nÃ£o possui tokens** â€” o cÃ³digo atual tenta queimar tokens da carteira do usuÃ¡rio (`burnFrom(userAddress)`), mas o usuÃ¡rio nÃ£o tem tokens onâ€‘chain.
3. **Signer incorreto** â€” algumas chamadas usavam um signer derivado da carteira do usuÃ¡rio em vez da chave do admin.
4. **DesconexÃ£o entre saldo onâ€‘chain e offâ€‘chain** â€” a plataforma atualiza o saldo do usuÃ¡rio offâ€‘chain, mas nÃ£o queima/minta na carteira correta.

Esses erros violam as prÃ¡ticas recomendadas de contratos ERC20: a funÃ§Ã£o `mint` sÃ³ pode ser chamada por quem possuir a `MINTER_ROLE` e atribui os tokens a um endereÃ§o especÃ­fico; a funÃ§Ã£o `burn` sÃ³ pode ser chamada por endereÃ§os autorizados com a `BURNER_ROLE`. AlÃ©m disso, Ã© comum proteger funÃ§Ãµes sensÃ­veis usando `onlyOwner` ou checar `msg.sender == owner`.

---

### âœ… AlteraÃ§Ãµes a realizar

> **Resumo:** Centralize todas as chamadas de `mint` e `burn` na carteira do admin, removendo qualquer referÃªncia a carteiras de usuÃ¡rios. Mantenha o controle do saldo dos usuÃ¡rios apenas offâ€‘chain.

1. **Configure variÃ¡veis de ambiente para o admin**
   No arquivo `.env` ou `config.ts`, defina (ou garanta que existam) as seguintes variÃ¡veis:

   ```bash
   ADMIN_PRIVATE_KEY=<chave_privada_da_carteira_admin>
   ADMIN_PUBLIC_ADDRESS=0xcd83c3f36396bcb3569240a3cb34f037ba310926 # exemplo
   TOKEN_CONTRACT_ADDRESS=<endereco_do_token>
   RPC_URL=<url_do_provedor_RPC>
   TOKEN_DECIMALS=18 # ajuste conforme o token
   ```

   Essas variÃ¡veis serÃ£o usadas para assinar transaÃ§Ãµes e definir o destino dos tokens.

2. **Crie/ajuste um serviÃ§o de blockchain (`tokenService.ts`)**
   Centralize a interaÃ§Ã£o com o contrato. Um exemplo usando `ethers.js`:

   ```ts
   import { ethers } from 'ethers';
   import TokenABI from '../abis/Token.json';

   const rpcUrl = process.env.RPC_URL!;
   const adminPrivateKey = process.env.ADMIN_PRIVATE_KEY!;
   const adminPublic = process.env.ADMIN_PUBLIC_ADDRESS!;
   const tokenAddress = process.env.TOKEN_CONTRACT_ADDRESS!;
   const decimals = parseInt(process.env.TOKEN_DECIMALS || '18');

   const provider = new ethers.JsonRpcProvider(rpcUrl);
   const wallet = new ethers.Wallet(adminPrivateKey, provider);
   const tokenContract = new ethers.Contract(tokenAddress, TokenABI, wallet);

   // Converte valor para o nÃºmero correto de casas decimais
   function toWei(amount: number | string) {
     return ethers.parseUnits(amount.toString(), decimals);
   }

   export async function mintTokens(amount: number | string) {
     // SÃ³ mintar na carteira admin. NÃ£o use userAddress aqui!
     const weiAmount = toWei(amount);
     const tx = await tokenContract.mint(adminPublic, weiAmount);
     await tx.wait();
     return tx.hash;
   }

   export async function burnTokens(amount: number | string) {
     // Queima os tokens da prÃ³pria carteira admin
     const weiAmount = toWei(amount);
     // Se o contrato exigir burn(uint256), chama diretamente:
     const tx = await tokenContract.burn(weiAmount);
     // Se o contrato exigir burnFrom(address,uint256):
     // const tx = await tokenContract.burn(adminPublic, weiAmount);
     await tx.wait();
     return tx.hash;
   }
   ```

   ğŸ” **ObservaÃ§Ã£o:** conforme o contrato usado na Xâ€‘Change, a funÃ§Ã£o `mint` exige `MINTER_ROLE` e um endereÃ§o alvo; a funÃ§Ã£o `burn` requer `BURNER_ROLE` e elimina tokens do chamador. Certifiqueâ€‘se de que a carteira admin possua essas permissÃµes.

3. **Corrija o endpoint de depÃ³sito (mint)**
   No `paymentController.ts` ou rota equivalente, onde a plataforma aprova o depÃ³sito do usuÃ¡rio:

   ```ts
   // Supondo req.body.amount seja o valor em BRL3 a ser creditado em tokens
   const amount = Number(req.body.amount);
   // 1. Atualize saldo offâ€‘chain do usuÃ¡rio
   await creditUserBalance(userId, amount);
   // 2. Chame o serviÃ§o de mint na carteira admin (onâ€‘chain)
   await mintTokens(amount);
   // 3. Retorne sucesso
   res.json({ message: 'DepÃ³sito aprovado e tokens mintados na carteira admin' });
   ```

   **Importante:** nÃ£o envie `to: userAddress` para a API do Xâ€‘Change; envie `to: ADMIN_PUBLIC_ADDRESS`.

4. **Corrija o endpoint de saque (burn)**
   No `withdrawController.ts` ou rota equivalente:

   ```ts
   const amount = Number(req.body.amount);
   // Verifique se o usuÃ¡rio tem saldo offâ€‘chain suficiente
   if (!(await hasBalance(userId, amount))) {
     return res.status(400).json({ error: 'Saldo insuficiente' });
   }
   // 1. Debite o saldo offâ€‘chain do usuÃ¡rio
   await debitUserBalance(userId, amount);
   // 2. Queime tokens na carteira admin
   await burnTokens(amount);
   res.json({ message: 'Saque aprovado e tokens queimados da carteira admin' });
   ```

   O usuÃ¡rio **nÃ£o** paga gas nem assina transaÃ§Ãµes.

5. **Atualize a chamada da API Xâ€‘Change (se existir)**
   Caso a PalpitesAI faÃ§a chamadas HTTP ao gateway da Xâ€‘Change para mint/burn, a payload deve ter sempre o endereÃ§o admin:

   ```ts
   await axios.post('/xchange/mint', {
     to: process.env.ADMIN_PUBLIC_ADDRESS,
     amount: amountInWei.toString(),
     apiKey: process.env.XCHANGE_API_KEY
   });
   // e para burn:
   await axios.post('/xchange/burn', {
     from: process.env.ADMIN_PUBLIC_ADDRESS,
     amount: amountInWei.toString(),
     apiKey: process.env.XCHANGE_API_KEY
   });
   ```

   Assim, a Xâ€‘Change chamarÃ¡ `mint(adminWallet, amount)` e `burn(adminWallet, amount)` no contrato.

6. **Remova lÃ³gica de userWallet**
   Elimine qualquer lÃ³gica de:

   ```ts
   const { userWallet } = req.body;
   await tokenContract.mint(userWallet, weiAmount);
   ```

   ou `burnFrom(userWallet, weiAmount)`. Essas chamadas estÃ£o incorretas porque o usuÃ¡rio nÃ£o tem tokens onâ€‘chain.

7. **ValidaÃ§Ã£o e tratamento de erros**

   * Verifique o valor (`amount > 0`).
   * Envolva as chamadas `mintTokens` e `burnTokens` em blocos `try/catch` para capturar erros de transaÃ§Ã£o.
   * Retorne mensagens claras em caso de falha.

---

### ğŸ“Œ Resultado

Com essas mudanÃ§as:

* **Toda nova emissÃ£o de tokens (mint) serÃ¡ feita para a carteira do administrador**, em conformidade com a restriÃ§Ã£o de que somente endereÃ§os com `MINTER_ROLE` podem criar tokens.
* **Toda queima (burn) serÃ¡ realizada a partir da carteira do administrador**, seguindo a exigÃªncia de que apenas quem possui `BURNER_ROLE` pode destruir tokens.
* O usuÃ¡rio mantÃ©m seu saldo somente no banco de dados offâ€‘chain, sem jamais interagir com o contrato nem pagar gas.
* Seu sistema PalpitesAI seguirÃ¡ exatamente o fluxo que funcionava na Xâ€‘Change, mas aplicado ao modelo de conta Ãºnica do admin.

Implementando esse prompt no Replit, o problema de mint/burn na carteira do admin serÃ¡ resolvido.
