Pelo log anexado o *build* e o *bundle* concluem com sucesso; o erro ocorre no **Promote** devido a falhas no *health check* da plataforma de deployments da Replit. Ao analisar o projeto completo encontrei trÃªs causas principais:

1. **Conflito de portas na configuraÃ§Ã£o do `.replit`.**
   O arquivo `.replit` define mÃºltiplas portas (`5000`, `3001`, `3002`, `5173`, etc.). Na fase de deploy, a Replit expÃµe apenas uma porta externa (tipicamente `80`). Cada porta adicional cria um contÃªiner separado e gera conflitos. Isso explica as mensagens â€œPotential port conflictâ€ e, posteriormente, a falha no *health check*.

2. **Endpoint de saÃºde inexistente ou lento.**
   A Replit verifica se a aplicaÃ§Ã£o responde rapidamente a uma requisiÃ§Ã£o `GET /`. O servidor atual sÃ³ serve o front-end via Vite/Express (que lÃª arquivos do disco) e ainda dispara um *auto-seed* pesado no `registerRoutes`, que fica aguardando a sincronizaÃ§Ã£o com a API do Polymarket. Isso causa timeout no `/` e impede que o health check responda em tempo hÃ¡bil.

3. **Seed automÃ¡tico e mirror rodando antes da aplicaÃ§Ã£o iniciar.**
   A funÃ§Ã£o `autoSeedIfEmpty()` Ã© chamada com `await`, o que bloqueia o boot enquanto ela baixa dados externos (Polymarket) e insere registros no banco. AlÃ©m disso, o mirror de odds e o cron podem ser iniciados enquanto a aplicaÃ§Ã£o ainda estÃ¡ subindo. Caso ocorram erros no `@neondatabase/serverless` (ex.: `cannot read properties of undefined (reading 'size')`), o servidor cai antes mesmo de ouvir conexÃµes.

Para corrigir definitivamente esses problemas, vocÃª pode aplicar as seguintes mudanÃ§as e republicar:

---

### ğŸ› ï¸ 1. Limpar o `.replit` e unificar as portas

Edite o arquivo `.replit` para deixar **apenas uma porta local ligada Ã  porta externa 80** e ajustar os comandos de build/run:

```toml
# .replit corrigido
run = ["npm", "run", "start"]

[deployment]
deploymentTarget = "autoscale"
build = ["npm", "run", "build"]
run = ["npm", "run", "start"]

[[ports]]
localPort = 5000
externalPort = 80

[env]
PORT = "5000"
```

Apague todas as outras entradas de `[[ports]]` (3000, 5173, 3001, etc.) e, se necessÃ¡rio, remova as portas extras via painel *Networking* no Replit.

---

### ğŸ› ï¸ 2. Criar um endpoint de saÃºde rÃ¡pido

No `server/index.ts`, adicione um endpoint simples que responde imediatamente (antes das rotas pesadas ou da serveStatic):

```ts
// server/index.ts
// ... imports e configuraÃ§Ã£o existentes ...

const app = express();
app.use(express.json({ verify: (req, _res, buf) => { req.rawBody = buf; } }));
app.use(express.urlencoded({ extended: false }));

// âœ… Endpoint de saÃºde na raiz (usado pelo health check do deploy)
app.get("/", (_req, res) => {
  res.status(200).send("OK");
});

// ... cÃ³digo de logging e setup (registerRoutes) ...
```

Isso garante que o `/` responda um `200 OK` em milissegundos, atendendo o health check, sem bloquear com seed ou mirror.

---

### ğŸ› ï¸ 3. Rodar o seed em background (nÃ£o bloquear a subida)

No `server/routes.ts`, substitua o `await autoSeedIfEmpty()` por uma execuÃ§Ã£o assÃ­ncrona sem `await`, para que o servidor continue inicializando enquanto o seed acontece:

```ts
// server/routes.ts
// ... dentro de registerRoutes ...
// Antes:
await autoSeedIfEmpty();

// Depois:
autoSeedIfEmpty().catch((error) => {
  console.error("Auto-seed failed:", error);
});
```

Dessa forma, se o banco precisar ser populado, isso ocorre â€œpor trÃ¡sâ€ e nÃ£o faz o boot travar nem o health check falhar.

---

### ğŸ› ï¸ 4. Garantir que variÃ¡veis de ambiente existam

No painel **Secrets** do Replit, configure pelo menos:

* `DATABASE_URL` â†’ string de conexÃ£o PostgreSQL (Replit gera automaticamente se vocÃª provisionou o mÃ³dulo `postgresql-16`).
* `SESSION_SECRET` â†’ string aleatÃ³ria forte.
* Mantenha `ENABLE_POLYMARKET=true` e outras variÃ¡veis (`POLYMARKET_GAMMA_URL`, etc.) conforme jÃ¡ estÃ£o no `.env`.

Sem essas variÃ¡veis, o `server/db.ts` lanÃ§a erro ao iniciar e a aplicaÃ§Ã£o nunca chega a responder.

---

### âœ”ï¸ Resultado

Depois de aplicar essas mudanÃ§as:

1. Execute `npm run build` localmente para garantir que nÃ£o haja erros.
2. Rode `npm run start` e acesse `http://localhost:5000/`; vocÃª deverÃ¡ ver "OK".
3. Clique em **Republish** no Replit. O *health check* passarÃ¡ porque a rota `/` responde imediatamente, e o deploy seguirÃ¡ atÃ© o fim, expondo a aplicaÃ§Ã£o em `https://<nome>.replit.app`.

AlÃ©m dessas correÃ§Ãµes, verifique se estÃ¡ usando a versÃ£o mais recente do `@neondatabase/serverless` (>=â€¯0.10.4) e atualize se necessÃ¡rio para evitar erros como â€œcannot read properties of undefinedâ€.

Seguindo esse passo a passo, vocÃª elimina os conflitos de porta, garante um endpoint de saÃºde rÃ¡pido e evita bloquear o boot com tarefas pesadas â€” e o seu app serÃ¡ republicado com sucesso.
