Bora fechar o MVP direito — com **código plug-and-play**, **modelagem de preço com spread de 2%**, **arquitetura PIX→BRL3 custodial (sem carteira obrigatória)**, **histórico p/ gráficos**, e **rebranding roxo clean**.

Abaixo está o **pacote completo**: backend (Node/Express + Postgres), cron de coleta/normalização das odds “by slug”, motor de cotação com spread, serviço de hedge (opcional), frontend (React + Tailwind + Chart.js) e guidelines de design. Cito a doc da Polymarket onde for crítico (endpoints e regras de preço).

---

# Fontes essenciais (Polymarket)

* **Builder intro** (conceito de “builder” que roteia ordens). ([Polymarket Documentation][1])
* **Gamma Markets API** → **Get market by slug** e **Get markets** (descoberta/slug). ([Polymarket Documentation][2])
* **Guia “fetch by slug”** (exatamente o que vamos usar). ([Polymarket Documentation][3])
* **Como os preços são exibidos** (midpoint do book, ou último negócio se spread > $0,10). ([Polymarket Documentation][4])
* **CLOB: book/price(s)** (best bid/ask + lote) — útil para calcular mid-price e verificar liquidez para hedge. ([Polymarket Documentation][5])
* **Timeseries (histórico)** para construir os gráficos. ([Polymarket Documentation][6])
* **Builder keys / signing server** (se quiser rotear ordens para lá). ([Polymarket Documentation][7])
* **Visão geral da Gamma API** (read-only público para dados). ([Polymarket Documentation][8])

---

# Arquitetura (resumo executivo)

**Cliente** (web)
→ **API** (Node/Express)
→ **Polymarket Gamma** (dados dos mercados) + **CLOB** (book/price history)
→ **Postgres** (markets + snapshots p/ gráficos + ledger de saldos)
→ **PSP PIX** (depósitos/saques)
→ **Carteira Tesouraria BRL3** (on-chain, invisível ao usuário no MVP)

**Fluxo do usuário (MVP custodial, zero fricção):**

1. **Depósito PIX** → credita **Saldo em R$** (e espelha **Saldo em BRL3** em ledger interno).
2. Usuário escolhe mercado, **compra/vende** no seu front; você cota **odds = Polymarket ± spread** (ver abaixo).
3. (Opcional) **Hedge**: você executa na Polymarket para “zerar” o risco, capturando o **spread de 2%** quando o fill ocorre.
4. **Saque PIX**: debita saldo e liquida via PSP.

> O cliente **não precisa conectar MetaMask** no MVP. O BRL3 fica como **lastro/contabilidade**; só vocês enxergam a parte on-chain por ora.

---

# Banco de dados (Postgres)

```sql
-- Ledger / KYC mínimo
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT UNIQUE,
  name TEXT,
  kyc_level TEXT DEFAULT 'basic',
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE wallets ( -- opcional, futura integração on-chain
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id),
  evm_address TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE balances (
  user_id UUID PRIMARY KEY REFERENCES users(id),
  fiat_cents BIGINT NOT NULL DEFAULT 0,   -- R$ em centavos
  brl3_units BIGINT NOT NULL DEFAULT 0,   -- 1 unit = R$0,01 (espelhado)
  updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE pix_transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id),
  type TEXT CHECK(type IN ('DEPOSIT','WITHDRAW')),
  amount_cents BIGINT NOT NULL,
  status TEXT CHECK(status IN ('PENDING','CONFIRMED','FAILED')) DEFAULT 'PENDING',
  psp_ref TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Mercados e histórico p/ gráficos
CREATE TABLE markets (
  slug TEXT PRIMARY KEY,
  title TEXT,
  outcomes JSONB,            -- ex: [{"name":"Yes","prob":56.1},...]
  volume NUMERIC,            -- se disponível
  last_update TIMESTAMPTZ
);

CREATE TABLE market_history (
  id BIGSERIAL PRIMARY KEY,
  slug TEXT REFERENCES markets(slug),
  ts TIMESTAMPTZ NOT NULL,
  outcomes JSONB              -- mesmo shape do 'outcomes'
);

-- Ordens do usuário (internas)
CREATE TABLE orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id),
  slug TEXT REFERENCES markets(slug),
  side TEXT CHECK(side IN ('BUY','SELL')),
  outcome TEXT,              -- "Yes"/"No" ou "Lula", etc.
  price_bp INTEGER,          -- basis points de prob (ex 5630 = 56,30%)
  size_cents BIGINT,         -- tamanho em R$ (centavos)
  status TEXT CHECK(status IN ('NEW','FILLED','CANCELLED','REJECTED')) DEFAULT 'NEW',
  hedge_status TEXT CHECK(hedge_status IN ('NONE','PENDING','HEDGED','FAILED')) DEFAULT 'NONE',
  created_at TIMESTAMPTZ DEFAULT now()
);
```

---

# Backend (Node/Express)

## 1) Dependências & estrutura

```
server/
  app.js
  config.js
  db.js
  markets.js
  quotes.js        // calculo de preço + spread + validações
  hedger.js        // opcional: execução de hedge na Polymarket
  cron.js          // snapshot histórico
  routes/
    markets.js     // GET /api/markets, GET /api/market-history
    trading.js     // POST /api/order, POST /api/quote
```

`package.json`: `express`, `pg`, `node-fetch`, `zod`, `pino`, `cors`, `dotenv`, `cron`.

### `config.js`

```js
export const POLY_GAMMA = 'https://gamma-api.polymarket.com';
export const POLY_CLOB = 'https://clob.polymarket.com';
export const SLUG_WHITELIST = [
  'brazil-presidential-election-2026',
  // ...até 10
];

export const DISPLAY_DECIMALS = 1; // % com 1 casa
export const UI_SPREAD = 0.02;     // 2% (ad valorem sobre o preço)
export const SNAPSHOT_SEC = 60;    // frequência do histórico

// Se for usar execução/hedge de fato:
// export const BUILDER_KEY = process.env.BUILDER_KEY;
// export const BUILDER_ADDR = process.env.BUILDER_ADDR;
```

## 2) Coleta “by slug” + normalização

> Regras para “espelhar” odds de forma estável:
>
> * Para **exibir** probabilidade, use **mid-price** do book quando o spread ≤ $0,10; se maior, use **último negócio** (regra da própria Polymarket). ([Polymarket Documentation][4])
> * “Fetch by slug” via **Gamma API**. ([Polymarket Documentation][2])
> * Se quiser o **book**/best bid-ask direto: CLOB **/book**. ([Polymarket Documentation][9])

```js
// server/markets.js
import fetch from 'node-fetch';
import { POLY_GAMMA, POLY_CLOB, DISPLAY_DECIMALS } from './config.js';

async function fetchMarketBySlug(slug){
  const r = await fetch(`${POLY_GAMMA}/markets/slug/${encodeURIComponent(slug)}`);
  if (!r.ok) throw new Error(`Gamma slug ${slug} fail ${r.status}`);
  const m = await r.json(); // shape: ver doc

  // outcomes: alguns payloads já trazem prob; senão busque book/token
  // Vamos montar outcomes com {name, prob (0..1)}
  const outcomes = [];
  for (const o of m.outcomes ?? []) {
    let name = o.name || o.ticker || o.id;
    let prob = o.probability; // 0..1 se existir

    if (prob == null) {
      // tentar mid-price do book (Yes/No ou candidato)
      // m.outcomes[i].tokenId (ou asset_id) é necessário
      const token = o.token_id || o.tokenId || o.asset_id;
      if (token) {
        const br = await fetch(`${POLY_CLOB}/book?token_id=${token}`);
        if (br.ok) {
          const b = await br.json();
          const bestBid = Number(b.best_bid ?? 0)/100;  // docs retornam em "cents" em várias rotas
          const bestAsk = Number(b.best_ask ?? 0)/100;
          if (bestBid > 0 && bestAsk > 0) {
            const spread = bestAsk - bestBid;
            prob = (spread <= 0.10 && spread > 0)
              ? (bestBid + bestAsk)/2
              : undefined;
          }
        }
      }
    }

    // fallback: last trade (quando spread > 0.10), se houver
    if (prob == null) {
      // alguns payloads incluem last_price; se não houver, você pode
      // consultar /prices-history e pegar o último ponto disponível
      const last = o.last_price || o.price;
      if (last != null) prob = Number(last);
    }

    outcomes.push({ name, prob: Number(prob ?? 0) });
  }

  // Normalizar para % (multi-outcome)
  const sum = outcomes.reduce((a,b)=>a + (b.prob||0), 0) || 1;
  const normalized = outcomes.map(o => ({
    name: o.name,
    percent: +(((o.prob||0)/sum)*100).toFixed(DISPLAY_DECIMALS),
    raw: o.prob ?? 0
  }));

  return {
    slug,
    title: m.question || m.title || slug,
    outcomes: normalized,
    volume: m.volume,
    endsAt: m.end_date_iso || m.endDate,
    raw: m
  };
}

export async function getWhitelistedMarkets(slugs){
  return Promise.all(slugs.map(fetchMarketBySlug));
}
```

> Observação: a doc pública da **Gamma** é read-only para dados. Para **books, preços e histórico** usamos os endpoints do **CLOB** (`/book`, `/prices-history`). ([Polymarket Documentation][8])

## 3) Quotes com **spread de 2%**

**Ideia:** você **vende mais barato** que a Polymarket e **captura 2%** sobre o preço (ad valorem). Para BUY (cliente comprando **Yes**), sua cotação é:

```
p_ui = clamp( p_poly * (1 - 0.02), 0.01, 0.99 )
```

Para SELL (cliente te vendendo **Yes**), simetricamente:

```
p_ui = clamp( p_poly * (1 + 0.02), 0.01, 0.99 )
```

> Esse modelo gera **receita no ato** se você **hedgear** a mercado na Polymarket perto do mid-price. Riscos: **slippage**, **latência** e **liquidez do book** (se o melhor ask voar antes do seu fill, você pode ficar “descoberto”). Use **cotas máximas por mercado** e **cheque liquidez** antes de aceitar a ordem. Para checar liquidez rapidamente, use `POST /prices` (melhor bid/ask em lote) ou `/book` por token. ([Polymarket Documentation][10])

```js
// server/quotes.js
import { UI_SPREAD } from './config.js';

export function applySpread(polyPrice, side){
  // polyPrice: 0..1 (já em prob)
  if (side === 'BUY') return Math.min(0.99, Math.max(0.01, polyPrice * (1 - UI_SPREAD)));
  if (side === 'SELL') return Math.min(0.99, Math.max(0.01, polyPrice * (1 + UI_SPREAD)));
  return polyPrice;
}
```

### Rota de cotação (com checagem de liquidez)

```js
// server/routes/trading.js (trecho)
router.post('/quote', async (req,res)=>{
  const { slug, outcome, side, sizeCents } = req.body; // valida com zod
  const m = await fetchMarketBySlug(slug);

  const o = m.outcomes.find(x => x.name === outcome);
  if (!o) return res.status(400).json({error:'Outcome inválido'});

  const poly = o.raw;       // 0..1
  const priceUI = applySpread(poly, side);

  // Checar book p/ garantir liquidez mínima pro hedge
  const tokenId = /* recupere do m.raw/outcome correspondente */;
  const book = await fetch(`${POLY_CLOB}/book?token_id=${tokenId}`).then(r=>r.json());
  const bestAsk = Number(book.best_ask ?? 0)/100;
  const bestBid = Number(book.best_bid ?? 0)/100;

  // Regra simples: só autoriza BUY se bestAsk <= poly + 0.02
  // (limita risco de levar "gap" na hora do hedge)
  if (side === 'BUY' && !(bestAsk > 0)) {
    return res.status(409).json({error:'Liquidez insuficiente'});
  }

  return res.json({
    slug, outcome, side,
    price: priceUI,              // 0..1
    price_display: +(priceUI*100).toFixed(2), // %
    size_cents: sizeCents
  });
});
```

## 4) Execução/hedge (opcional no MVP)

Se optar por **hedgear** (recomendado), você vai precisar de **Builder keys** e o **Signing Server** da Polymarket para autenticar/envio de ordens no CLOB. ([Polymarket Documentation][7])
Estratégia: ao **aceitar** a ordem do cliente, enviar **ordem agressiva** (taker) na Polymarket do **lado oposto** para travar o PnL e **cravar o spread**.

> Importante: se ainda não quer executar ordens reais, **logue** o hedge desejado e simule fill a preço do best bid/ask para medir risco.

```js
// server/hedger.js (esqueleto)
export async function hedgeOrder({ slug, outcome, side, sizeCents, polyTokenId }) {
  // side BUY (cliente compra Yes) => hedge = COMPRAR Yes na Poly? (se você é “intermediário roteando”)
  // ajuste conforme seu modelo de exposição.
  // Aqui apenas pseudocódigo.
  /*
  const order = {
    token_id: polyTokenId,
    side: side === 'BUY' ? 'BUY' : 'SELL',
    price: /* bestAsk/bestBid */,
    size: /* sizeCents em "shares" / conversão */,
    builder_auth: /* headers com assinatura */
  };
  const r = await fetch(`${POLY_CLOB}/order`, { method:'POST', headers, body: JSON.stringify(order) });
  return await r.json();
  */
}
```

## 5) Snapshots para **gráficos**

Use cron cada **60s** para: (i) buscar todos os slugs, (ii) normalizar outcomes → % e (iii) gravar em `market_history`.

```js
// server/cron.js
import cron from 'node-cron';
import { SLUG_WHITELIST } from './config.js';
import { getWhitelistedMarkets } from './markets.js';
import db from './db.js';

export function startSnapshots(){
  cron.schedule('*/1 * * * *', async ()=>{
    const list = await getWhitelistedMarkets(SLUG_WHITELIST);
    const ts = new Date();
    for (const m of list) {
      await db.upsertMarket(m);
      await db.insertHistory(m.slug, ts, m.outcomes);
    }
  });
}
```

## 6) API de dados para o front

```js
// server/routes/markets.js
import express from 'express';
import db from '../db.js';

const router = express.Router();

router.get('/markets', async (req,res)=>{
  const rows = await db.listMarkets(); // título, outcomes (atuais), volume
  res.json(rows);
});

router.get('/market-history', async (req,res)=>{
  const { slug, range = '1M' } = req.query;
  const points = await db.listHistory(slug, range);
  res.json(points);
});

export default router;
```

---

# Frontend (React + Tailwind + Chart.js)

## 1) Rebranding (Palpites.AI)

**Paleta (roxos futuristas, 100% clean):**

* `--p-900: #1a102a` (bg escuro)
* `--p-700: #352b50`
* `--p-500: #6f3df4` (primária)
* `--p-300: #a789ff`
* `--p-100: #efe9ff`
* Acento hover: **gradiente** `linear-gradient(135deg, #6f3df4, #a789ff)`

**Tipografia:** Inter ou Sora (titles sem serifa).
**Componentes:** cartões com **bordas 2xl**, **sombras suaves**, **muito espaço em branco**, ícones **lucide-react**.
**Remover “Atividade Recente”** (lateral).
**Cards da home:** 2 colunas (desktop), 1 no mobile; cada card mostra: **título**, **% por outcome**, **variação 24h** (se quiser), botão “Ver mercado”.

### Tailwind config (trecho)

```js
// tailwind.config.js
theme: {
  extend: {
    colors: {
      brand: {
        100: '#efe9ff',
        300: '#a789ff',
        500: '#6f3df4',
        700: '#352b50',
        900: '#1a102a'
      }
    },
    borderRadius: { '2xl': '1.25rem' }
  }
}
```

## 2) Páginas/Componentes

```
client/
  src/
    App.jsx
    pages/
      Home.jsx
      Market.jsx
    components/
      MarketCard.jsx
      MarketChart.jsx
      QuoteTicket.jsx
      Layout.jsx
```

### `MarketCard.jsx`

```jsx
export default function MarketCard({ market, onOpen }){
  return (
    <div className="rounded-2xl bg-brand-900/60 border border-brand-700 p-4 hover:shadow-lg">
      <h3 className="text-white text-lg mb-3">{market.title}</h3>
      <div className="grid grid-cols-2 gap-2">
        {market.outcomes.map(o=>(
          <div key={o.name} className="rounded-xl bg-brand-700/60 p-3">
            <div className="text-brand-100 text-sm">{o.name}</div>
            <div className="text-white text-xl">{o.percent}%</div>
          </div>
        ))}
      </div>
      <button
        onClick={()=>onOpen(market.slug)}
        className="mt-4 w-full py-2 rounded-xl text-white"
        style={{ background: 'linear-gradient(135deg,#6f3df4,#a789ff)' }}>
        Ver mercado
      </button>
    </div>
  );
}
```

### `MarketChart.jsx` (linhas por outcome)

```jsx
import { Line } from 'react-chartjs-2';
import { useEffect, useState } from 'react';

export default function MarketChart({ slug, range='1M' }){
  const [series, setSeries] = useState([]);

  useEffect(()=>{
    fetch(`/api/market-history?slug=${slug}&range=${range}`)
      .then(r=>r.json()).then(setSeries);
  }, [slug, range]);

  const labels = series.map(p => new Date(p.ts).toLocaleString());
  const names = series[0]?.outcomes.map(o=>o.name) ?? [];
  const datasets = names.map((name, i)=>({
    label: name,
    data: series.map(p => p.outcomes[i]?.percent ?? null),
    tension: .25,
    pointRadius: 0
  }));

  return (
    <Line data={{ labels, datasets }}
      options={{
        plugins:{ legend:{ position:'bottom' }},
        scales:{ y:{ min:0, max:100, title:{display:true, text:'% chance'} } }
      }}
    />
  );
}
```

### `QuoteTicket.jsx` (aplica spread)

```jsx
import { useEffect, useState } from 'react';

export default function QuoteTicket({ slug, outcome }){
  const [side, setSide] = useState('BUY');
  const [amt, setAmt] = useState(100);
  const [quote, setQuote] = useState(null);

  useEffect(()=>{
    fetch('/api/quote', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ slug, outcome, side, sizeCents: Math.round(amt*100) })
    }).then(r=>r.json()).then(setQuote);
  }, [slug, outcome, side, amt]);

  return (
    <div className="rounded-2xl bg-brand-900/60 border border-brand-700 p-4">
      <div className="flex gap-2 mb-2">
        <button onClick={()=>setSide('BUY')}
          className={`flex-1 py-2 rounded-xl ${side==='BUY'?'bg-brand-500 text-white':'bg-brand-700 text-brand-100'}`}>Comprar</button>
        <button onClick={()=>setSide('SELL')}
          className={`flex-1 py-2 rounded-xl ${side==='SELL'?'bg-brand-500 text-white':'bg-brand-700 text-brand-100'}`}>Vender</button>
      </div>
      <div className="mb-2">
        <label className="text-brand-100 text-sm">Valor (R$)</label>
        <input type="number" value={amt} onChange={e=>setAmt(+e.target.value)}
          className="w-full rounded-lg bg-brand-700/60 text-white p-2"/>
      </div>
      <div className="text-brand-100 text-sm mb-1">Preço com spread (2%)</div>
      <div className="text-white text-2xl mb-3">{quote ? `${quote.price_display}%` : '...'}</div>
      <button className="w-full py-2 rounded-xl text-white"
        style={{ background: 'linear-gradient(135deg,#6f3df4,#a789ff)' }}>
        Confirmar
      </button>
    </div>
  );
}
```

### Página de **Mercado** (detalhe)

* Cabeçalho: título + filtros (1D/1W/1M/ALL)
* **Gráfico** (MarketChart)
* **Outcomes** com % atual
* **Ordem** (QuoteTicket)
* Aviso: “As probabilidades são derivadas da Polymarket. Exibimos cotação com **spread de 2%**.”

---

# PIX ↔ BRL3 (custodial simples)

**Depósito**

1. Cliente gera QR do **PSP PIX**.
2. Webhook confirma, cria `pix_transactions (CONFIRMED)`.
3. `balances.fiat_cents += valor; balances.brl3_units += valor` (espelho 1:1).
4. Logue a reconciliação diária (saldo total dos usuários **≤** BRL3 na **tesouraria**).

**Saque**

1. Cliente solicita saque (PIX).
2. `balances.fiat_cents -= valor` e `brl3_units -= valor`.
3. PSP envia PIX.

> **BRL3** é só **back-office** no MVP (sem swap externo). O usuário vê **apenas R$**.

**Controles mínimos**

* **Rate limits** por usuário/mercado
* **Limites de exposição** por mercado
* **Reconciliação**: total `brl3_units` dos usuários **nunca** pode exceder BRL3 disponível na **carteira tesouraria**.
* **Auditoria**: cada crédito/débito referenciado a `pix_transactions.id`.

---

# Risco, PnL e hedge (curto e direto)

* **Receita alvo**: 2% **ad valorem** sobre o preço exibido.
* **Fontes de risco**: (i) **slippage** vs best bid/ask, (ii) **latência** (cotou e o book mudou), (iii) **falta de liquidez** (pedido não preenche), (iv) **descasamento** se não hedgear imediatamente.
* **Mitigações**:

  1. **Checar book** e **tamanho** antes de aceitar ordem;
  2. **Cotar por no máx. 3s** (expiração da quote);
  3. **Hedge imediato** (taker) após aceitação;
  4. **Circuit breaker** por mercado (desabilita novas ordens se spread do book > 10c ou liquidez < X). A regra de exibição da Polymarket usa last trade quando spread > 10c — sinal de mercado “fino”. ([Polymarket Documentation][4])

---

# Gráficos (histórico Polymarket)

Quando possível, use o **/prices-history** do CLOB (por token) — você pode plotar **Yes** e **No** separadamente ou reconstruir multi-outcomes. ([Polymarket Documentation][11])
Se não cobrir tudo, seus **snapshots** (cron de 60s) garantem o gráfico.

---

# Segurança e confiabilidade

* **Cache** de 5–10s nos endpoints de mercado (evita rate-limit).
* **Schema validation** (Zod) em todas as rotas (especialmente ordens).
* **Idempotência** em depósitos/saques (chave PSP `psp_ref`).
* **Observabilidade**: logs com `pino` + IDs de correlação por request.
* **Testes**: mocks da Gamma/CLOB + testes de normalização (binário e N-outcomes).
* **Fail-safe**: se a API da Polymarket cair, congelar cotações (somente leitura).

---

# Checklist de entrega

* [ ] Postgres com tabelas acima
* [ ] **/api/markets** (lista) e **/api/market-history** (gráfico)
* [ ] **/api/quote** aplicando **spread 2%** e checando book/liquidez
* [ ] **Cron 60s** salvando snapshots
* [ ] **Home** com cards (rebranding roxo)
* [ ] **Detalhe** com gráfico + ticket de ordem
* [ ] Fluxo **PIX** (deposit/withdraw) integrado ao **ledger**
* [ ] Reconciliação diária BRL3 (tesouraria) × saldos de usuários

---

## Notas finais e “porquês” (referências)

* **Buscar por slug** é o caminho mais simples e controlável (você escolhe até 10 mercados). ([Polymarket Documentation][3])
* **Exibição de preço** da Polymarket: **midpoint** do best bid/ask (ou **last trade** se o spread > $0,10) — espelhar isso evita divergências. ([Polymarket Documentation][4])
* **Gamma API** é **read-only** (descoberta/metadata); para **book/histórico**, use **CLOB**. ([Polymarket Documentation][8])
* Se decidir **rotear ordens** (sendo realmente um “builder”), você usará **Builder Keys + Signing Server**. ([Polymarket Documentation][7])

---

Se quiser, no próximo passo eu empacoto isso em um **repositório** (server + client) com:

* Docker Compose (Postgres + API + Web)
* Scripts `npm run seed` (slugs) e `npm run cron`
* Variáveis `.env` exemplo (PSP fake, Gamma/CLOB endpoints)

Assim você só pluga seu PSP de PIX, configura os 10 **slugs** e sobe.

[1]: https://docs.polymarket.com/developers/builders/builder-intro?utm_source=chatgpt.com "Builder Program Introduction"
[2]: https://docs.polymarket.com/api-reference/markets/get-market-by-slug?utm_source=chatgpt.com "Get market by slug"
[3]: https://docs.polymarket.com/developers/gamma-markets-api/fetch-markets-guide?utm_source=chatgpt.com "How to Fetch Markets"
[4]: https://docs.polymarket.com/polymarket-learn/trading/how-are-prices-calculated?utm_source=chatgpt.com "How Are Prices Calculated?"
[5]: https://docs.polymarket.com/developers/CLOB/prices-books/get-book?utm_source=chatgpt.com "Get Book"
[6]: https://docs.polymarket.com/developers/CLOB/timeseries?utm_source=chatgpt.com "Historical Timeseries Data"
[7]: https://docs.polymarket.com/developers/builders/builder-profile?utm_source=chatgpt.com "Builder Profile & Keys"
[8]: https://docs.polymarket.com/developers/gamma-markets-api/overview?utm_source=chatgpt.com "Overview - Polymarket Documentation"
[9]: https://docs.polymarket.com/api-reference/orderbook/get-order-book-summary?utm_source=chatgpt.com "Get order book summary"
[10]: https://docs.polymarket.com/developers/CLOB/prices-books/get-prices?utm_source=chatgpt.com "Get Price(s)"
[11]: https://docs.polymarket.com/api-reference/pricing/get-price-history-for-a-traded-token?utm_source=chatgpt.com "Get price history for a traded token"
