Perfeito âœ… â€” entÃ£o vocÃª quer um **arquivo de lista** (ex: `delete_list.txt`) onde cada linha contÃ©m o caminho de um arquivo ou pasta que deve ser excluÃ­do, e o Replit **lÃª e apaga automaticamente tudo que estiver nessa lista**.

Vamos fazer isso em **duas partes**:

---

## ğŸ§© 1ï¸âƒ£ Script de varredura â€” cria a lista `delete_list.txt`

Este script sÃ³ analisa o projeto e **gera a lista de arquivos/pastas inÃºteis** (sem deletar ainda).

Crie um arquivo chamado `generate_delete_list.py` e cole o seguinte:

```python
import os

# Caminho raiz
root_dir = "."

# ConfiguraÃ§Ãµes
MB = 1024 * 1024
useless_ext = [".log", ".tmp", ".map", ".DS_Store", ".lock", ".swp", ".bak", ".old", ".orig"]
irrelevant_folders = ["node_modules", "__pycache__", ".git", ".next", ".cache", "dist", "build"]

delete_list = []

for root, dirs, files in os.walk(root_dir):
    # Ignora diretÃ³rios do sistema Replit
    if ".replit" in root or "venv" in root:
        continue

    for d in dirs:
        folder_path = os.path.join(root, d)
        if any(bad in d for bad in irrelevant_folders):
            delete_list.append(folder_path)

    for f in files:
        file_path = os.path.join(root, f)
        ext = os.path.splitext(f)[1].lower()
        try:
            size = os.path.getsize(file_path)
            if ext in useless_ext or size > 5 * MB or any(
                x in f.lower() for x in ["backup", "copy", "temp", "duplicate"]
            ):
                delete_list.append(file_path)
        except:
            continue

# Remove duplicatas
delete_list = sorted(list(set(delete_list)))

# Cria a lista
with open("delete_list.txt", "w", encoding="utf-8") as f:
    f.write("\n".join(delete_list))

print("âœ… Lista criada: delete_list.txt")
print(f"Total de itens identificados: {len(delete_list)}")
print("Revise o arquivo antes de executar a exclusÃ£o.")
```

---

## ğŸ§© 2ï¸âƒ£ Script de exclusÃ£o â€” lÃª a lista e deleta tudo

Depois de revisar a lista e confirmar que os caminhos estÃ£o corretos,
crie outro arquivo chamado `delete_from_list.py`:

```python
import os
import shutil

delete_list_file = "delete_list.txt"

if not os.path.exists(delete_list_file):
    print("âŒ Arquivo delete_list.txt nÃ£o encontrado.")
    exit()

with open(delete_list_file, "r", encoding="utf-8") as f:
    items = [line.strip() for line in f.readlines() if line.strip()]

print(f"ğŸ—‘ï¸ Itens para excluir: {len(items)}")

confirm = input("Tem certeza que deseja excluir TODOS esses arquivos e pastas? (digite SIM): ")

if confirm.strip().upper() == "SIM":
    for item in items:
        if os.path.isdir(item):
            try:
                shutil.rmtree(item)
                print(f"âœ… Pasta removida: {item}")
            except Exception as e:
                print(f"âš ï¸ Erro ao remover pasta {item}: {e}")
        elif os.path.isfile(item):
            try:
                os.remove(item)
                print(f"ğŸ—‘ï¸ Arquivo removido: {item}")
            except Exception as e:
                print(f"âš ï¸ Erro ao remover arquivo {item}: {e}")
    print("\nâœ… Limpeza concluÃ­da com sucesso!")
else:
    print("ğŸš« OperaÃ§Ã£o cancelada.")
```

---

## âš™ï¸ Como usar no Replit

1. Coloque **ambos os scripts** na raiz do seu projeto.
2. Execute `generate_delete_list.py` â†’ ele cria o arquivo `delete_list.txt`.
3. Abra o `delete_list.txt`, revise o conteÃºdo.
4. Execute `delete_from_list.py`.
5. Quando o script pedir confirmaÃ§Ã£o, digite `SIM`.

---

Quer que eu adicione uma linha para **registrar tudo que foi deletado em um log**, tipo `deleted_log.txt` (com data e tamanho)? Isso ajuda a manter histÃ³rico.
