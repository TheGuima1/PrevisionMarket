Great â€” now that you're looking to have an **AI agent** build this system, and you're starting from scratch (i.e., **markets exist but have zero liquidity**, meaning no trades or pricing yet), hereâ€™s a full set of **step-by-step instructions** for the AI agent to build a **Polymarket-style prediction market system** with no liquidity initially added.

This is a **replicable protocol-level instruction set** suitable for:

* An autonomous AI developer
* A simulation environment
* A smart contract prototype
* Or even a Web2/3 hybrid platform

---

# ğŸ“‹ **AI Agent Instructions: Build a Zero-Liquidity Prediction Market System (Polymarket-style)**

---

## ğŸ§  GOAL

Create a binary prediction market platform where:

* Markets can be created without initial liquidity.
* Traders can later add capital and trade on YES/NO outcomes.
* Prices emerge dynamically based on trades.
* The AMM updates prices and reserves accordingly.
* Outcomes resolve via oracle or admin for simulation purposes.

---

## ğŸ§± 1. **System Overview**

Create a modular system with the following components:

| Module          | Description                                        |
| --------------- | -------------------------------------------------- |
| `MarketFactory` | Creates new binary markets                         |
| `Market`        | Each market has YES/NO outcomes, AMM, and state    |
| `AMMEngine`     | Implements pricing and trading logic (`x * y = k`) |
| `UserAccount`   | Simulates user balance, shares, and trades         |
| `Oracle`        | Resolves outcomes post-event                       |
| `Interface`     | Optional UI or CLI to interact with system         |

---

## ğŸ—ï¸ 2. **Core Objects to Implement**

### ğŸ”¹ A. Market

Each market should have:

```json
{
  "question": "Will X happen?",
  "outcomes": ["YES", "NO"],
  "reserves": {
    "YES": 0,
    "NO": 0
  },
  "k": 0,
  "resolved": false,
  "winner": null,
  "trades": []
}
```

Note: Reserves start at **0**, meaning the **price is undefined until the first trade**.

---

### ğŸ”¹ B. UserAccount

```json
{
  "id": "user1",
  "usdc_balance": 1000,
  "shares": {
    "market1": {
      "YES": 0,
      "NO": 0
    }
  }
}
```

---

## âš™ï¸ 3. **System Functions (Modules)**

---

### ğŸ§± `MarketFactory.create_market()`

```python
def create_market(question):
    return {
        "question": question,
        "reserves": {"YES": 0, "NO": 0},
        "k": 0,
        "resolved": False,
        "winner": None,
        "trades": []
    }
```

* Each market is **price-neutral at launch**
* No liquidity is seeded initially
* `k` is calculated **only after first trade**

---

### ğŸ§® `AMMEngine.get_price(outcome, market)`

* If no liquidity â†’ return `None` or display â€œPrice not yet availableâ€
* Else, use:

  ```python
  price_yes = y / (x + y)
  price_no = x / (x + y)
  ```

---

### ğŸ’¸ `AMMEngine.buy_shares(user, market, outcome, usdc_amount)`

Steps:

1. **If market has zero liquidity**:

   * Use this trade to **initialize reserves**
   * Example: $100 into YES â†’
     `market["reserves"]["YES"] += 100`
     `market["reserves"]["NO"] += Îµ` (small dummy amount, e.g., 0.01, to avoid div/0)
   * Set `k = x * y`

2. **If liquidity exists**:

   * Run iterative function to simulate slippage along CPMM curve
   * Deduct USDC from user
   * Update reserves and shares
   * Update `k`

Returns:

* # of shares bought
* new price

---

### ğŸ›‘ `AMMEngine.sell_shares(user, market, outcome, shares)`

(Optional if early-exit trading is allowed.)

Reverse trade mechanics:

* Selling YES increases YES reserve and decreases NO
* Compute payout = USDC received
* Respect AMM pricing to avoid arbitrage

---

### ğŸ§ª `Oracle.resolve_market(market, winner)`

Sets the winning outcome.

```python
market["resolved"] = True
market["winner"] = "YES"
```

Users can now **redeem winning shares for $1 each**.

---

### ğŸ¦ `UserAccount.redeem_winnings(user, market)`

```python
if market["resolved"]:
    payout = user.shares[market][market["winner"]] * 1
    user.usdc_balance += payout
```

---

## ğŸ“‰ 4. **Handling Zero Liquidity at Launch**

Since you start with **zero liquidity**, the system must:

* Treat the **first buyer as the LP**
* Use their capital to establish initial reserves
* This avoids the need for Polymarket-style LP partners

### Example:

User buys $100 YES:

* Set `reserves = {"YES": 100, "NO": 0.01}`
* Set `k = 1.0` * 100 = `1.0`
* This allows next buyer to pay slightly more

---

## ğŸ§ª 5. **Simulation Scenario (Sample Flow)**

1. `create_market("Will Bitcoin hit $100K by EOY?")`
2. No price shown yet (zero liquidity)
3. User1 buys $100 of YES:

   * Reserves â†’ YES: 100, NO: 0.01
   * Price(YES) â‰ˆ 0.9999
4. User2 buys $50 of NO:

   * AMM updates reserves
   * Price rebalances
5. After event:

   * Admin/Oracle sets winner
   * Users redeem winning shares

---

## ğŸ§  6. **Optional Enhancements**

* Allow users to **add liquidity directly** as LPs
* Implement **fees** (e.g., 2%) on trades
* Add **market expiry timestamps**
* Let users **sell before resolution**
* Visualize **price vs volume** chart

---

## ğŸ’¾ 7. Suggested File Structure (Python)

```bash
/market_system
  â”œâ”€â”€ main.py
  â”œâ”€â”€ market_factory.py
  â”œâ”€â”€ amm_engine.py
  â”œâ”€â”€ user_account.py
  â”œâ”€â”€ oracle.py
  â”œâ”€â”€ simulation.py
  â””â”€â”€ utils.py
```

---

## âœ… 8. Final Checklist

| Task                              | Done? |
| --------------------------------- | ----- |
| Market creation with no liquidity | âœ…     |
| Dynamic pricing via AMM           | âœ…     |
| First trade seeds reserves        | âœ…     |
| k = x * y maintained              | âœ…     |
| Price = y / (x + y)               | âœ…     |
| Oracle resolution                 | âœ…     |
| Share redemption                  | âœ…     |

---

## ğŸ§  Summary

You're building a minimal Polymarket clone where:

* Markets start **without any capital**
* Traders define the **initial price and liquidity**
* AMM pricing follows **constant product logic**
* Probabilities are **emergent**, not pre-set
* Oracles finalize outcomes

This design allows full simulation or smart contract deployment. If needed, I can generate a working prototype in Python or write pseudo-smart contracts in Solidity based on this logic.

---

Would you like:

* A working **Python simulation** script?
* A **Solidity smart contract version** of this?
* Or a **GUI mockup** for interaction?

Let me know your preferred implementation path.
